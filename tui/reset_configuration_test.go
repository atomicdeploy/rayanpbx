package main

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// TestClearPjsipConfig tests that managed sections are properly cleared from pjsip.conf
func TestClearPjsipConfig(t *testing.T) {
	// Create a temporary directory for test files
	tmpDir := t.TempDir()
	
	// Create a mock pjsip.conf with managed sections
	pjsipContent := `; RayanPBX PJSIP Configuration
; Generated by RayanPBX

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060

; BEGIN MANAGED - Extension 101
[101]
type=endpoint
context=from-internal
auth=101
aors=101

[101]
type=auth
auth_type=userpass
password=secret
username=101

[101]
type=aor
max_contacts=1
; END MANAGED - Extension 101

; BEGIN MANAGED - Extension 102
[102]
type=endpoint
context=from-internal
auth=102
aors=102

[102]
type=auth
auth_type=userpass
password=secret2
username=102

[102]
type=aor
max_contacts=1
; END MANAGED - Extension 102

; BEGIN MANAGED - RayanPBX Hello World Extension
[999]
type=endpoint
; END MANAGED - RayanPBX Hello World Extension
`

	pjsipPath := filepath.Join(tmpDir, "pjsip.conf")
	if err := os.WriteFile(pjsipPath, []byte(pjsipContent), 0644); err != nil {
		t.Fatalf("Failed to create test pjsip.conf: %v", err)
	}

	// For testing, we'll directly call the patterns removal logic
	// (The test file is prepared above but we test the pattern matching directly)
	content := pjsipContent

	patterns := []string{
		`(?s); BEGIN MANAGED - Extension \d+.*?; END MANAGED - Extension \d+\n`,
		`(?s); BEGIN MANAGED - RayanPBX Hello World Extension.*?; END MANAGED - RayanPBX Hello World Extension\n`,
	}

	for _, pattern := range patterns {
		re := MustCompilePattern(pattern)
		if re != nil {
			content = re.ReplaceAllString(content, "")
		}
	}

	// Verify that managed sections are removed
	if strings.Contains(content, "; BEGIN MANAGED - Extension 101") {
		t.Error("Extension 101 section was not removed")
	}
	if strings.Contains(content, "; BEGIN MANAGED - Extension 102") {
		t.Error("Extension 102 section was not removed")
	}
	if strings.Contains(content, "; BEGIN MANAGED - RayanPBX Hello World Extension") {
		t.Error("Hello World Extension section was not removed")
	}
	if strings.Contains(content, "[101]") {
		t.Error("Extension 101 config was not removed")
	}
	if strings.Contains(content, "[102]") {
		t.Error("Extension 102 config was not removed")
	}

	// Verify that non-managed sections remain
	if !strings.Contains(content, "[transport-udp]") {
		t.Error("transport-udp section was incorrectly removed")
	}
	if !strings.Contains(content, "type=transport") {
		t.Error("Transport configuration was incorrectly removed")
	}
}

// TestClearExtensionsConfig tests that managed sections are properly cleared from extensions.conf
func TestClearExtensionsConfig(t *testing.T) {
	// Create a mock extensions.conf with managed sections
	extContent := `; RayanPBX Dialplan Configuration
; Generated by RayanPBX

[general]
static=yes

[globals]

[from-internal]
exten = s,1,Answer()

; BEGIN MANAGED - RayanPBX Internal Extensions
[internal]
exten => 1001,1,NoOp(Call to extension 1001)
same => n,Dial(PJSIP/1001,30)
same => n,Hangup()
; END MANAGED - RayanPBX Internal Extensions

; BEGIN MANAGED - RayanPBX Hello World Dialplan
[from-internal-test]
exten = 100,1,Answer()
same = n,Playback(hello-world)
same = n,Hangup()
; END MANAGED - RayanPBX Hello World Dialplan

[from-external]
exten = s,1,Answer()
`

	content := extContent

	patterns := []string{
		`(?s); BEGIN MANAGED - RayanPBX Internal Extensions.*?; END MANAGED - RayanPBX Internal Extensions\n`,
		`(?s); BEGIN MANAGED - RayanPBX Hello World Dialplan.*?; END MANAGED - RayanPBX Hello World Dialplan\n`,
	}

	for _, pattern := range patterns {
		re := MustCompilePattern(pattern)
		if re != nil {
			content = re.ReplaceAllString(content, "")
		}
	}

	// Verify that managed sections are removed
	if strings.Contains(content, "; BEGIN MANAGED - RayanPBX Internal Extensions") {
		t.Error("Internal Extensions section was not removed")
	}
	if strings.Contains(content, "; BEGIN MANAGED - RayanPBX Hello World Dialplan") {
		t.Error("Hello World Dialplan section was not removed")
	}
	if strings.Contains(content, "[internal]") {
		t.Error("Internal context was not removed")
	}
	if strings.Contains(content, "Dial(PJSIP/1001,30)") {
		t.Error("Internal dialplan was not removed")
	}

	// Verify that non-managed sections remain
	if !strings.Contains(content, "[general]") {
		t.Error("general section was incorrectly removed")
	}
	if !strings.Contains(content, "[from-external]") {
		t.Error("from-external section was incorrectly removed")
	}
	if !strings.Contains(content, "[from-internal]") {
		t.Error("from-internal section was incorrectly removed")
	}
}

// TestResetResultHasErrors tests the HasErrors function
func TestResetResultHasErrors(t *testing.T) {
	result := &ResetResult{
		Errors: []string{},
	}

	if result.HasErrors() {
		t.Error("HasErrors should return false for empty errors slice")
	}

	result.Errors = append(result.Errors, "test error")

	if !result.HasErrors() {
		t.Error("HasErrors should return true when there are errors")
	}
}

// TestGetSummary tests the summary generation
func TestGetSummary(t *testing.T) {
	rc := &ResetConfiguration{
		verbose: true,
	}

	summary, err := rc.GetSummary()
	if err != nil {
		t.Fatalf("GetSummary failed: %v", err)
	}

	// Verify summary contains expected sections
	if !strings.Contains(summary, "⚠️  This will reset ALL configuration") {
		t.Error("Summary should contain warning header")
	}
	if !strings.Contains(summary, "THIS ACTION CANNOT BE UNDONE") {
		t.Error("Summary should contain undoable warning")
	}
}

// MustCompilePattern is a helper to compile regex patterns, returning nil on error
func MustCompilePattern(pattern string) *Regexp {
	re, err := CompilePattern(pattern)
	if err != nil {
		return nil
	}
	return re
}

// Regexp is an alias for testing
type Regexp = regexp.Regexp

// CompilePattern compiles a regex pattern
func CompilePattern(pattern string) (*regexp.Regexp, error) {
	return regexp.Compile(pattern)
}
