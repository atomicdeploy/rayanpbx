package main

import (
	"strings"
	"testing"
)

// TestClearPjsipConfig tests that extensions can be properly removed from pjsip.conf
func TestClearPjsipConfig(t *testing.T) {
	// Create a mock pjsip.conf content
	pjsipContent := `; RayanPBX PJSIP Configuration
; Generated by RayanPBX

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060

[101]
type=endpoint
context=from-internal
auth=101
aors=101

[101]
type=auth
auth_type=userpass
password=secret
username=101

[101]
type=aor
max_contacts=1

[102]
type=endpoint
context=from-internal
auth=102
aors=102

[102]
type=auth
auth_type=userpass
password=secret2
username=102

[102]
type=aor
max_contacts=1
`

	// Parse the config
	config, err := ParseAsteriskConfigContent(pjsipContent, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Should have transport + 6 extension sections (3 for each extension)
	if len(config.Sections) != 7 {
		t.Errorf("Expected 7 sections, got %d", len(config.Sections))
	}

	// Remove extension 101
	removed := config.RemoveSectionsByName("101")
	if removed != 3 {
		t.Errorf("Expected to remove 3 sections for 101, removed %d", removed)
	}

	// Remove extension 102
	removed = config.RemoveSectionsByName("102")
	if removed != 3 {
		t.Errorf("Expected to remove 3 sections for 102, removed %d", removed)
	}

	// Verify that transport remains
	if !config.HasSectionWithType("transport-udp", "transport") {
		t.Error("transport-udp section was incorrectly removed")
	}

	// Verify extensions are removed
	if config.HasSection("101") {
		t.Error("Extension 101 was not removed")
	}
	if config.HasSection("102") {
		t.Error("Extension 102 was not removed")
	}
}

// TestClearExtensionsConfig tests that dialplan sections can be properly managed
func TestClearExtensionsConfig(t *testing.T) {
	// Create a mock extensions.conf content
	extContent := `; RayanPBX Dialplan Configuration
; Generated by RayanPBX

[general]
static=yes

[globals]

[from-internal]
exten=s,1,Answer()

[internal]
exten=1001,1,NoOp(Call to extension 1001)

[from-external]
exten=s,1,Answer()
`

	// Parse the config
	config, err := ParseAsteriskConfigContent(extContent, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Verify we can find all sections
	if !config.HasSection("general") {
		t.Error("Expected to find general section")
	}
	if !config.HasSection("from-internal") {
		t.Error("Expected to find from-internal section")
	}
	if !config.HasSection("internal") {
		t.Error("Expected to find internal section")
	}
	if !config.HasSection("from-external") {
		t.Error("Expected to find from-external section")
	}

	// Remove internal section
	config.RemoveSectionsByName("internal")

	// Verify internal is removed but others remain
	if config.HasSection("internal") {
		t.Error("Internal section was not removed")
	}
	if !config.HasSection("general") {
		t.Error("general section was incorrectly removed")
	}
	if !config.HasSection("from-external") {
		t.Error("from-external section was incorrectly removed")
	}
	if !config.HasSection("from-internal") {
		t.Error("from-internal section was incorrectly removed")
	}
}

// TestResetResultHasErrors tests the HasErrors function
func TestResetResultHasErrors(t *testing.T) {
	result := &ResetResult{
		Errors: []string{},
	}

	if result.HasErrors() {
		t.Error("HasErrors should return false for empty errors slice")
	}

	result.Errors = append(result.Errors, "test error")

	if !result.HasErrors() {
		t.Error("HasErrors should return true when there are errors")
	}
}

// TestGetSummary tests the summary generation
func TestGetSummary(t *testing.T) {
	rc := &ResetConfiguration{
		verbose: true,
	}

	summary, err := rc.GetSummary()
	if err != nil {
		t.Fatalf("GetSummary failed: %v", err)
	}

	// Verify summary contains expected sections
	if !strings.Contains(summary, "⚠️  This will reset ALL configuration") {
		t.Error("Summary should contain warning header")
	}
	if !strings.Contains(summary, "THIS ACTION CANNOT BE UNDONE") {
		t.Error("Summary should contain undoable warning")
	}
}
