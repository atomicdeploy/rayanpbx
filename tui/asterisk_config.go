package main

import (
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"github.com/fatih/color"
)

// AsteriskConfigManager handles Asterisk configuration file management
type AsteriskConfigManager struct {
	pjsipConfigPath string
	verbose         bool
}

// NewAsteriskConfigManager creates a new config manager
func NewAsteriskConfigManager(verbose bool) *AsteriskConfigManager {
	return &AsteriskConfigManager{
		pjsipConfigPath: "/etc/asterisk/pjsip.conf",
		verbose:         verbose,
	}
}

// GeneratePjsipEndpoint generates PJSIP configuration for an extension
func (acm *AsteriskConfigManager) GeneratePjsipEndpoint(ext Extension) string {
	var config strings.Builder

	config.WriteString(fmt.Sprintf("\n; BEGIN MANAGED - Extension %s\n", ext.ExtensionNumber))
	
	// Endpoint section
	config.WriteString(fmt.Sprintf("[%s]\n", ext.ExtensionNumber))
	config.WriteString("type=endpoint\n")
	config.WriteString(fmt.Sprintf("context=%s\n", ext.Context))
	config.WriteString("disallow=all\n")
	
	// Add codecs
	codecs := []string{"ulaw", "alaw", "g722"}
	for _, codec := range codecs {
		config.WriteString(fmt.Sprintf("allow=%s\n", codec))
	}
	
	config.WriteString(fmt.Sprintf("transport=%s\n", ext.Transport))
	config.WriteString(fmt.Sprintf("auth=%s\n", ext.ExtensionNumber))
	config.WriteString(fmt.Sprintf("aors=%s\n", ext.ExtensionNumber))
	config.WriteString("direct_media=no\n")
	
	if ext.CallerID != "" {
		config.WriteString(fmt.Sprintf("callerid=%s\n", ext.CallerID))
	}
	
	// Auth section
	config.WriteString(fmt.Sprintf("\n[%s]\n", ext.ExtensionNumber))
	config.WriteString("type=auth\n")
	config.WriteString("auth_type=userpass\n")
	config.WriteString(fmt.Sprintf("username=%s\n", ext.ExtensionNumber))
	config.WriteString(fmt.Sprintf("password=%s\n", ext.Secret))
	
	// AOR section
	config.WriteString(fmt.Sprintf("\n[%s]\n", ext.ExtensionNumber))
	config.WriteString("type=aor\n")
	config.WriteString(fmt.Sprintf("max_contacts=%d\n", ext.MaxContacts))
	config.WriteString("remove_existing=yes\n")
	config.WriteString("qualify_frequency=60\n")
	
	config.WriteString(fmt.Sprintf("; END MANAGED - Extension %s\n", ext.ExtensionNumber))
	
	return config.String()
}

// WritePjsipConfig writes or updates PJSIP configuration
func (acm *AsteriskConfigManager) WritePjsipConfig(content, identifier string) error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("ðŸ“ Updating configuration file: %s\n", acm.pjsipConfigPath)
		cyan.Printf("   Identifier: %s\n", identifier)
	}

	// Check if file exists
	existingContent, err := os.ReadFile(acm.pjsipConfigPath)
	if err != nil {
		// If file doesn't exist, try to create it with proper header
		if os.IsNotExist(err) {
			yellow.Printf("âš ï¸  Config file not found, creating: %s\n", acm.pjsipConfigPath)
			header := "; RayanPBX PJSIP Configuration\n; Generated by RayanPBX TUI\n\n"
			existingContent = []byte(header)
		} else {
			return fmt.Errorf("failed to read config file: %v", err)
		}
	}

	// Remove old managed section for this identifier
	pattern := fmt.Sprintf(`(?s); BEGIN MANAGED - %s.*?; END MANAGED - %s\n`, regexp.QuoteMeta(identifier), regexp.QuoteMeta(identifier))
	re := regexp.MustCompile(pattern)
	newContent := re.ReplaceAllString(string(existingContent), "")

	// Append new config
	newContent += content

	// Write to file
	err = os.WriteFile(acm.pjsipConfigPath, []byte(newContent), 0644)
	if err != nil {
		red.Printf("âŒ Failed to write config file: %v\n", err)
		yellow.Println("ðŸ’¡ Tip: Make sure the TUI has write permissions to /etc/asterisk/")
		yellow.Println("ðŸ’¡ Try running with: sudo rayanpbx-tui")
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Printf("âœ… Configuration updated successfully\n")
		green.Printf("   File: %s\n", acm.pjsipConfigPath)
	}

	return nil
}

// RemovePjsipConfig removes a configuration section
func (acm *AsteriskConfigManager) RemovePjsipConfig(identifier string) error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("ðŸ—‘ï¸  Removing configuration for: %s\n", identifier)
	}

	existingContent, err := os.ReadFile(acm.pjsipConfigPath)
	if err != nil {
		return fmt.Errorf("failed to read config file: %v", err)
	}

	// Remove managed section
	pattern := fmt.Sprintf(`(?s); BEGIN MANAGED - %s.*?; END MANAGED - %s\n`, regexp.QuoteMeta(identifier), regexp.QuoteMeta(identifier))
	re := regexp.MustCompile(pattern)
	newContent := re.ReplaceAllString(string(existingContent), "")

	// Write back
	err = os.WriteFile(acm.pjsipConfigPath, []byte(newContent), 0644)
	if err != nil {
		red.Printf("âŒ Failed to write config file: %v\n", err)
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Printf("âœ… Configuration removed successfully\n")
	}

	return nil
}

// ReloadAsterisk reloads Asterisk configuration
func (acm *AsteriskConfigManager) ReloadAsterisk() error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Println("ðŸ”„ Reloading Asterisk PJSIP module...")
	}

	// Try to find asterisk binary in common locations
	asteriskPaths := []string{
		"/usr/sbin/asterisk",
		"/usr/bin/asterisk",
		"/usr/local/sbin/asterisk",
		"/usr/local/bin/asterisk",
	}
	
	var asteriskBin string
	for _, path := range asteriskPaths {
		if _, err := os.Stat(path); err == nil {
			asteriskBin = path
			break
		}
	}
	
	// Fallback to PATH if not found in common locations
	if asteriskBin == "" {
		asteriskBin = "asterisk"
	}

	// Try to reload via asterisk CLI
	cmd := exec.Command(asteriskBin, "-rx", "module reload res_pjsip.so")
	output, err := cmd.CombinedOutput()
	
	if err != nil {
		red.Printf("âŒ Failed to reload Asterisk: %v\n", err)
		red.Printf("Output: %s\n", string(output))
		return fmt.Errorf("failed to reload asterisk: %v", err)
	}

	if acm.verbose {
		green.Println("âœ… Asterisk reloaded successfully")
		if len(output) > 0 {
			fmt.Printf("   Output: %s\n", strings.TrimSpace(string(output)))
		}
	}

	return nil
}
