package main

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/fatih/color"
)

// AsteriskConfigManager handles Asterisk configuration file management
type AsteriskConfigManager struct {
	pjsipConfigPath string
	verbose         bool
}

// NewAsteriskConfigManager creates a new config manager
func NewAsteriskConfigManager(verbose bool) *AsteriskConfigManager {
	return &AsteriskConfigManager{
		pjsipConfigPath: "/etc/asterisk/pjsip.conf",
		verbose:         verbose,
	}
}

// GeneratePjsipEndpoint generates PJSIP configuration for an extension
// Uses best-practice defaults from "Config #2" style while allowing customization
// Returns the sections that should be added to the config
func (acm *AsteriskConfigManager) GeneratePjsipEndpoint(ext Extension) []*AsteriskSection {
	// Parse codecs
	codecList := []string{"ulaw", "alaw", "g722"}
	if ext.Codecs != "" {
		codecList = strings.Split(ext.Codecs, ",")
	}

	// Set default direct_media if not specified
	directMedia := ext.DirectMedia
	if directMedia == "" {
		directMedia = "no"
	}

	// Create sections using the helper function
	return CreatePjsipEndpointSections(
		ext.ExtensionNumber,
		ext.Secret,
		ext.Context,
		ext.Transport,
		codecList,
		directMedia,
		ext.CallerID,
		ext.MaxContacts,
		ext.QualifyFrequency,
		ext.VoicemailEnabled,
	)
}

// GeneratePjsipEndpointString generates PJSIP configuration for an extension as a string
// This maintains backward compatibility with code that expects a string output
func (acm *AsteriskConfigManager) GeneratePjsipEndpointString(ext Extension) string {
	sections := acm.GeneratePjsipEndpoint(ext)
	var sb strings.Builder

	for i, section := range sections {
		sb.WriteString(section.String())
		if i < len(sections)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// WritePjsipConfigSections writes or updates PJSIP configuration using sections
func (acm *AsteriskConfigManager) WritePjsipConfigSections(sections []*AsteriskSection, identifier string) error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("üìù Updating configuration file: %s\n", acm.pjsipConfigPath)
		cyan.Printf("   Identifier: %s\n", identifier)
	}

	// Parse existing config or create new one
	var config *AsteriskConfig
	var err error

	if _, statErr := os.Stat(acm.pjsipConfigPath); os.IsNotExist(statErr) {
		// Create new config with header
		yellow.Printf("‚ö†Ô∏è  Config file not found, creating: %s\n", acm.pjsipConfigPath)
		config = &AsteriskConfig{
			HeaderLines: []string{"; RayanPBX PJSIP Configuration", "; Generated by RayanPBX TUI", ""},
			Sections:    []*AsteriskSection{},
			FilePath:    acm.pjsipConfigPath,
		}
	} else {
		config, err = ParseAsteriskConfig(acm.pjsipConfigPath)
		if err != nil {
			return fmt.Errorf("failed to read config file: %v", err)
		}
	}

	// Remove any existing sections with this identifier (extension number)
	// The identifier could be "Extension 101" format, extract the extension number
	extNumber := identifier
	if strings.HasPrefix(identifier, "Extension ") {
		extNumber = strings.TrimPrefix(identifier, "Extension ")
	}
	config.RemoveSectionsByName(extNumber)

	// Add new sections
	for _, section := range sections {
		config.AddSection(section)
	}

	// Write to file
	err = config.Save()
	if err != nil {
		red.Printf("‚ùå Failed to write config file: %v\n", err)
		yellow.Println("üí° Tip: Make sure the TUI has write permissions to /etc/asterisk/")
		yellow.Println("üí° Try running with: sudo rayanpbx-tui")
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Printf("‚úÖ Configuration updated successfully\n")
		green.Printf("   File: %s\n", acm.pjsipConfigPath)
	}

	// Commit changes to Git repository
	acm.CommitConfigChange("pjsip-update", fmt.Sprintf("Updated PJSIP config: %s", identifier))

	return nil
}

// WritePjsipConfig writes or updates PJSIP configuration for an extension
// Accepts string content for backward compatibility
func (acm *AsteriskConfigManager) WritePjsipConfig(content, identifier string) error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("üìù Updating configuration file: %s\n", acm.pjsipConfigPath)
		cyan.Printf("   Identifier: %s\n", identifier)
	}

	// Parse existing config or create new one
	var config *AsteriskConfig
	var err error

	if _, statErr := os.Stat(acm.pjsipConfigPath); os.IsNotExist(statErr) {
		// Create new config with header
		yellow.Printf("‚ö†Ô∏è  Config file not found, creating: %s\n", acm.pjsipConfigPath)
		config = &AsteriskConfig{
			HeaderLines: []string{"; RayanPBX PJSIP Configuration", "; Generated by RayanPBX TUI", ""},
			Sections:    []*AsteriskSection{},
			FilePath:    acm.pjsipConfigPath,
		}
	} else {
		config, err = ParseAsteriskConfig(acm.pjsipConfigPath)
		if err != nil {
			return fmt.Errorf("failed to read config file: %v", err)
		}
	}

	// Remove any existing sections with this identifier (extension number)
	// The identifier could be "Extension 101" format, extract the extension number
	extNumber := identifier
	if strings.HasPrefix(identifier, "Extension ") {
		extNumber = strings.TrimPrefix(identifier, "Extension ")
	}
	config.RemoveSectionsByName(extNumber)

	// Parse the new content as sections and add them
	newConfig, err := ParseAsteriskConfigContent(content, "")
	if err != nil {
		return fmt.Errorf("failed to parse new config content: %v", err)
	}

	for _, section := range newConfig.Sections {
		config.AddSection(section)
	}

	// Write to file
	err = config.Save()
	if err != nil {
		red.Printf("‚ùå Failed to write config file: %v\n", err)
		yellow.Println("üí° Tip: Make sure the TUI has write permissions to /etc/asterisk/")
		yellow.Println("üí° Try running with: sudo rayanpbx-tui")
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Printf("‚úÖ Configuration updated successfully\n")
		green.Printf("   File: %s\n", acm.pjsipConfigPath)
	}

	// Commit changes to Git repository
	acm.CommitConfigChange("pjsip-update", fmt.Sprintf("Updated PJSIP config: %s", identifier))

	return nil
}

// RemovePjsipConfig removes a configuration section
func (acm *AsteriskConfigManager) RemovePjsipConfig(identifier string) error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("üóëÔ∏è  Removing configuration for: %s\n", identifier)
	}

	config, err := ParseAsteriskConfig(acm.pjsipConfigPath)
	if err != nil {
		return fmt.Errorf("failed to read config file: %v", err)
	}

	// Extract the section name from the identifier
	// The identifier could be "Extension 101" format
	sectionName := identifier
	if strings.HasPrefix(identifier, "Extension ") {
		sectionName = strings.TrimPrefix(identifier, "Extension ")
	}

	// Remove all sections with this name (endpoint, auth, aor)
	removed := config.RemoveSectionsByName(sectionName)

	if removed == 0 {
		if acm.verbose {
			cyan.Printf("   No sections found for: %s\n", sectionName)
		}
	}

	// Write back
	err = config.Save()
	if err != nil {
		red.Printf("‚ùå Failed to write config file: %v\n", err)
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Printf("‚úÖ Configuration removed successfully (%d sections)\n", removed)
	}

	// Commit changes to Git repository
	acm.CommitConfigChange("pjsip-remove", fmt.Sprintf("Removed PJSIP config: %s", identifier))

	return nil
}

// ReloadAsterisk reloads Asterisk configuration
func (acm *AsteriskConfigManager) ReloadAsterisk() error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Println("üîÑ Reloading Asterisk PJSIP module...")
	}

	// Try to find asterisk binary in common locations
	asteriskPaths := []string{
		"/usr/sbin/asterisk",
		"/usr/bin/asterisk",
		"/usr/local/sbin/asterisk",
		"/usr/local/bin/asterisk",
	}
	
	var asteriskBin string
	for _, path := range asteriskPaths {
		if _, err := os.Stat(path); err == nil {
			asteriskBin = path
			break
		}
	}
	
	// Fallback to PATH if not found in common locations
	if asteriskBin == "" {
		asteriskBin = "asterisk"
	}

	// Try to reload via asterisk CLI
	cmd := exec.Command(asteriskBin, "-rx", "module reload res_pjsip.so")
	output, err := cmd.CombinedOutput()
	
	if err != nil {
		red.Printf("‚ùå Failed to reload Asterisk: %v\n", err)
		red.Printf("Output: %s\n", string(output))
		return fmt.Errorf("failed to reload asterisk: %v", err)
	}

	if acm.verbose {
		green.Println("‚úÖ Asterisk reloaded successfully")
		if len(output) > 0 {
			fmt.Printf("   Output: %s\n", strings.TrimSpace(string(output)))
		}
	}

	return nil
}

// GenerateTransportConfig generates complete PJSIP transport configuration
func (acm *AsteriskConfigManager) GenerateTransportConfig() string {
	sections := CreateTransportSections()
	var sb strings.Builder

	for i, section := range sections {
		sb.WriteString(section.String())
		if i < len(sections)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// EnsureTransportConfig ensures transport configuration exists in pjsip.conf
func (acm *AsteriskConfigManager) EnsureTransportConfig() error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Println("üì° Checking PJSIP transport configuration...")
	}

	// Parse existing config or create new one
	var config *AsteriskConfig
	var err error

	if _, statErr := os.Stat(acm.pjsipConfigPath); os.IsNotExist(statErr) {
		// Create new file with transport config
		if acm.verbose {
			yellow.Printf("‚ö†Ô∏è  Config file not found, creating: %s\n", acm.pjsipConfigPath)
		}
		config = &AsteriskConfig{
			HeaderLines: []string{"; RayanPBX PJSIP Configuration", "; Generated by RayanPBX", ""},
			Sections:    []*AsteriskSection{},
			FilePath:    acm.pjsipConfigPath,
		}
	} else {
		config, err = ParseAsteriskConfig(acm.pjsipConfigPath)
		if err != nil {
			return fmt.Errorf("failed to read config file: %v", err)
		}
	}

	// Check if both transports exist
	hasUDPTransport := config.HasSectionWithType("transport-udp", "transport")
	hasTCPTransport := config.HasSectionWithType("transport-tcp", "transport")

	if hasUDPTransport && hasTCPTransport {
		if acm.verbose {
			green.Println("‚úÖ PJSIP transports already configured")
		}
		return nil
	}

	if acm.verbose {
		yellow.Println("‚ö†Ô∏è  Transport configuration incomplete, updating...")
	}

	// Remove old transport sections if they exist (to ensure clean state)
	config.RemoveSectionsByName("transport-udp")
	config.RemoveSectionsByName("transport-tcp")

	// Add new transport sections at the beginning of sections
	transportSections := CreateTransportSections()
	
	// Prepend transport sections
	newSections := make([]*AsteriskSection, 0, len(transportSections)+len(config.Sections))
	newSections = append(newSections, transportSections...)
	newSections = append(newSections, config.Sections...)
	config.Sections = newSections

	// Write updated config
	err = config.Save()
	if err != nil {
		red.Printf("‚ùå Failed to write transport config: %v\n", err)
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Println("‚úÖ Transport configuration added successfully")
	}

	// Commit changes to Git repository
	acm.CommitConfigChange("transport-update", "Updated PJSIP transport configuration")

	return nil
}

// GenerateInternalDialplan generates dialplan configuration for internal extensions
// Uses [from-internal] context to match the endpoint context configuration
func (acm *AsteriskConfigManager) GenerateInternalDialplan(extensions []Extension) string {
	var config strings.Builder

	config.WriteString("\n[from-internal]\n")
	
	// Add individual extension rules
	for _, ext := range extensions {
		if !ext.Enabled {
			continue
		}
		
		config.WriteString(fmt.Sprintf("exten => %s,1,NoOp(Call to extension %s)\n", ext.ExtensionNumber, ext.ExtensionNumber))
		config.WriteString(fmt.Sprintf(" same => n,Dial(PJSIP/%s,30)\n", ext.ExtensionNumber))
		
		// Add voicemail if enabled
		if ext.VoicemailEnabled {
			config.WriteString(fmt.Sprintf(" same => n,VoiceMail(%s@default,u)\n", ext.ExtensionNumber))
		}
		
		config.WriteString(" same => n,Hangup()\n\n")
	}
	
	// Add pattern matching for extension-to-extension calls
	config.WriteString("; Pattern match for all extensions\n")
	config.WriteString("exten => _1XXX,1,NoOp(Extension to extension call: ${EXTEN})\n")
	config.WriteString(" same => n,Dial(PJSIP/${EXTEN},30)\n")
	config.WriteString(" same => n,Hangup()\n")
	
	return config.String()
}

// WriteDialplanConfig writes or updates dialplan configuration in extensions.conf
func (acm *AsteriskConfigManager) WriteDialplanConfig(content, identifier string) error {
	extensionsConfigPath := "/etc/asterisk/extensions.conf"
	
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("üìù Updating dialplan file: %s\n", extensionsConfigPath)
		cyan.Printf("   Identifier: %s\n", identifier)
	}

	// Parse existing config or create new one
	var config *AsteriskConfig
	var err error

	if _, statErr := os.Stat(extensionsConfigPath); os.IsNotExist(statErr) {
		yellow.Printf("‚ö†Ô∏è  Dialplan file not found, creating: %s\n", extensionsConfigPath)
		config = &AsteriskConfig{
			HeaderLines: []string{"; RayanPBX Dialplan Configuration", "; Generated by RayanPBX TUI", ""},
			Sections:    []*AsteriskSection{},
			FilePath:    extensionsConfigPath,
		}
	} else {
		config, err = ParseAsteriskConfig(extensionsConfigPath)
		if err != nil {
			return fmt.Errorf("failed to read dialplan file: %v", err)
		}
	}

	// For dialplan, we replace the [from-internal] context with the new content
	// Remove existing from-internal context
	config.RemoveSectionsByName("from-internal")

	// Parse the new content and add it
	newConfig, err := ParseAsteriskConfigContent(content, "")
	if err != nil {
		return fmt.Errorf("failed to parse new dialplan content: %v", err)
	}

	for _, section := range newConfig.Sections {
		config.AddSection(section)
	}

	// Write to file
	err = config.Save()
	if err != nil {
		red.Printf("‚ùå Failed to write dialplan file: %v\n", err)
		yellow.Println("üí° Tip: Make sure the TUI has write permissions to /etc/asterisk/")
		yellow.Println("üí° Try running with: sudo rayanpbx-tui")
		return fmt.Errorf("failed to write dialplan file: %v", err)
	}

	if acm.verbose {
		green.Printf("‚úÖ Dialplan updated successfully\n")
		green.Printf("   File: %s\n", extensionsConfigPath)
	}

	// Commit changes to Git repository
	acm.CommitConfigChange("dialplan-update", fmt.Sprintf("Updated dialplan: %s", identifier))

	return nil
}

// CommitConfigChange commits changes to the Asterisk configuration Git repository
// This creates a snapshot of the configuration for version control and rollback capability
func (acm *AsteriskConfigManager) CommitConfigChange(action, description string) error {
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)

	// Check if /etc/asterisk is a Git repository
	asteriskDir := "/etc/asterisk"
	gitDir := asteriskDir + "/.git"

	if _, err := os.Stat(gitDir); os.IsNotExist(err) {
		if acm.verbose {
			yellow.Println("‚ö†Ô∏è  /etc/asterisk is not a Git repository, skipping commit")
		}
		return nil // Not an error - just skip if not a git repo
	}

	// Try to use the helper script first
	scriptPaths := []string{
		"/opt/rayanpbx/scripts/asterisk-git-commit.sh",
		"/usr/local/bin/asterisk-git-commit.sh",
	}

	var scriptPath string
	for _, path := range scriptPaths {
		if _, err := os.Stat(path); err == nil {
			scriptPath = path
			break
		}
	}

	if scriptPath != "" {
		// Use the helper script
		cmd := exec.Command(scriptPath, "commit", action, description)
		cmd.Env = append(os.Environ(), "SOURCE=TUI", "RAYANPBX_TUI=1")
		output, err := cmd.CombinedOutput()
		if err != nil {
			if acm.verbose {
				yellow.Printf("‚ö†Ô∏è  Git commit helper failed: %v\n", err)
				yellow.Printf("   Output: %s\n", string(output))
			}
			// Fall through to inline git commit
		} else {
			if acm.verbose {
				green.Printf("‚úÖ Configuration snapshot saved\n")
			}
			return nil
		}
	}

	// Fallback: Inline git commit
	// Change to asterisk directory
	originalDir, err := os.Getwd()
	if err != nil {
		originalDir = "" // Mark as invalid
	}
	if err := os.Chdir(asteriskDir); err != nil {
		return nil // Silently skip if we can't change dir
	}
	defer func() {
		if originalDir != "" {
			_ = os.Chdir(originalDir) // Best effort restore
		}
	}()

	// Check if there are changes to commit
	statusCmd := exec.Command("git", "status", "--porcelain")
	statusOutput, err := statusCmd.Output()
	if err != nil || len(strings.TrimSpace(string(statusOutput))) == 0 {
		if acm.verbose {
			yellow.Println("‚ö†Ô∏è  No changes to commit")
		}
		return nil
	}

	// Stage all changes
	addCmd := exec.Command("git", "add", "-A")
	if err := addCmd.Run(); err != nil {
		if acm.verbose {
			yellow.Printf("‚ö†Ô∏è  Failed to stage changes: %v\n", err)
		}
		return nil
	}

	// Build commit message
	commitMsg := fmt.Sprintf("[%s] %s\n\nSource: TUI\nTimestamp: %s",
		action, description, getTimestamp())

	// Commit
	commitCmd := exec.Command("git", "commit", "-m", commitMsg)
	if output, err := commitCmd.CombinedOutput(); err != nil {
		if acm.verbose {
			yellow.Printf("‚ö†Ô∏è  Git commit failed: %v\n", err)
			yellow.Printf("   Output: %s\n", string(output))
		}
		return nil
	}

	if acm.verbose {
		green.Println("‚úÖ Configuration snapshot saved")
	}

	return nil
}

// getTimestamp returns current timestamp in standard format
func getTimestamp() string {
	return time.Now().Format("2006-01-02 15:04:05 MST")
}
