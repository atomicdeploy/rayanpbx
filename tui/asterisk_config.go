package main

import (
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"github.com/fatih/color"
)

// AsteriskConfigManager handles Asterisk configuration file management
type AsteriskConfigManager struct {
	pjsipConfigPath string
	verbose         bool
}

// NewAsteriskConfigManager creates a new config manager
func NewAsteriskConfigManager(verbose bool) *AsteriskConfigManager {
	return &AsteriskConfigManager{
		pjsipConfigPath: "/etc/asterisk/pjsip.conf",
		verbose:         verbose,
	}
}

// GeneratePjsipEndpoint generates PJSIP configuration for an extension
// Uses best-practice defaults from "Config #2" style while allowing customization
func (acm *AsteriskConfigManager) GeneratePjsipEndpoint(ext Extension) string {
	var config strings.Builder

	config.WriteString(fmt.Sprintf("\n; BEGIN MANAGED - Extension %s\n", ext.ExtensionNumber))
	
	// Endpoint section
	config.WriteString(fmt.Sprintf("[%s]\n", ext.ExtensionNumber))
	config.WriteString("type=endpoint\n")
	config.WriteString(fmt.Sprintf("context=%s\n", ext.Context))
	config.WriteString("disallow=all\n")
	
	// Add codecs from user configuration or defaults
	// Default codecs provide good compatibility: ulaw (US), alaw (EU), g722 (HD audio)
	codecList := []string{"ulaw", "alaw", "g722"}
	if ext.Codecs != "" {
		// Parse user-specified codecs
		codecList = strings.Split(ext.Codecs, ",")
	}
	for _, codec := range codecList {
		codec = strings.TrimSpace(codec)
		if codec != "" {
			config.WriteString(fmt.Sprintf("allow=%s\n", codec))
		}
	}
	
	config.WriteString(fmt.Sprintf("transport=%s\n", ext.Transport))
	config.WriteString(fmt.Sprintf("auth=%s\n", ext.ExtensionNumber))
	config.WriteString(fmt.Sprintf("aors=%s\n", ext.ExtensionNumber))
	
	// direct_media: Controls whether RTP goes directly between endpoints
	// "no" is recommended for NAT/firewall scenarios (safer default)
	// "yes" can be used in pure LAN environments for reduced server load
	directMedia := ext.DirectMedia
	if directMedia == "" {
		directMedia = "no"
	}
	config.WriteString(fmt.Sprintf("direct_media=%s\n", directMedia))
	
	if ext.CallerID != "" {
		config.WriteString(fmt.Sprintf("callerid=%s\n", ext.CallerID))
	}
	
	// Auth section
	config.WriteString(fmt.Sprintf("\n[%s]\n", ext.ExtensionNumber))
	config.WriteString("type=auth\n")
	config.WriteString("auth_type=userpass\n")
	config.WriteString(fmt.Sprintf("username=%s\n", ext.ExtensionNumber))
	config.WriteString(fmt.Sprintf("password=%s\n", ext.Secret))
	
	// AOR section (Address of Record)
	config.WriteString(fmt.Sprintf("\n[%s]\n", ext.ExtensionNumber))
	config.WriteString("type=aor\n")
	config.WriteString(fmt.Sprintf("max_contacts=%d\n", ext.MaxContacts))
	
	// remove_existing=yes: Clears old registrations when a new one arrives
	// This helps avoid stale registration issues
	config.WriteString("remove_existing=yes\n")
	
	// qualify_frequency: How often Asterisk pings the device to check if it's alive
	// 60 seconds is a good balance between responsiveness and overhead
	// 0 = disabled (user explicitly chose to disable)
	qualifyFreq := ext.QualifyFrequency
	// Only use default if qualify_frequency is 0 and wasn't explicitly set
	// We check if it equals the default value from the struct (which is 0 when not set)
	// and the user didn't provide it in the form
	config.WriteString(fmt.Sprintf("qualify_frequency=%d\n", qualifyFreq))
	
	config.WriteString(fmt.Sprintf("; END MANAGED - Extension %s\n", ext.ExtensionNumber))
	
	return config.String()
}

// WritePjsipConfig writes or updates PJSIP configuration
func (acm *AsteriskConfigManager) WritePjsipConfig(content, identifier string) error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("üìù Updating configuration file: %s\n", acm.pjsipConfigPath)
		cyan.Printf("   Identifier: %s\n", identifier)
	}

	// Check if file exists
	existingContent, err := os.ReadFile(acm.pjsipConfigPath)
	if err != nil {
		// If file doesn't exist, try to create it with proper header
		if os.IsNotExist(err) {
			yellow.Printf("‚ö†Ô∏è  Config file not found, creating: %s\n", acm.pjsipConfigPath)
			header := "; RayanPBX PJSIP Configuration\n; Generated by RayanPBX TUI\n\n"
			existingContent = []byte(header)
		} else {
			return fmt.Errorf("failed to read config file: %v", err)
		}
	}

	// Remove old managed section for this identifier
	pattern := fmt.Sprintf(`(?s); BEGIN MANAGED - %s.*?; END MANAGED - %s\n`, regexp.QuoteMeta(identifier), regexp.QuoteMeta(identifier))
	re := regexp.MustCompile(pattern)
	newContent := re.ReplaceAllString(string(existingContent), "")

	// Append new config
	newContent += content

	// Write to file
	err = os.WriteFile(acm.pjsipConfigPath, []byte(newContent), 0644)
	if err != nil {
		red.Printf("‚ùå Failed to write config file: %v\n", err)
		yellow.Println("üí° Tip: Make sure the TUI has write permissions to /etc/asterisk/")
		yellow.Println("üí° Try running with: sudo rayanpbx-tui")
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Printf("‚úÖ Configuration updated successfully\n")
		green.Printf("   File: %s\n", acm.pjsipConfigPath)
	}

	return nil
}

// RemovePjsipConfig removes a configuration section
func (acm *AsteriskConfigManager) RemovePjsipConfig(identifier string) error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("üóëÔ∏è  Removing configuration for: %s\n", identifier)
	}

	existingContent, err := os.ReadFile(acm.pjsipConfigPath)
	if err != nil {
		return fmt.Errorf("failed to read config file: %v", err)
	}

	// Remove managed section
	pattern := fmt.Sprintf(`(?s); BEGIN MANAGED - %s.*?; END MANAGED - %s\n`, regexp.QuoteMeta(identifier), regexp.QuoteMeta(identifier))
	re := regexp.MustCompile(pattern)
	newContent := re.ReplaceAllString(string(existingContent), "")

	// Write back
	err = os.WriteFile(acm.pjsipConfigPath, []byte(newContent), 0644)
	if err != nil {
		red.Printf("‚ùå Failed to write config file: %v\n", err)
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Printf("‚úÖ Configuration removed successfully\n")
	}

	return nil
}

// ReloadAsterisk reloads Asterisk configuration
func (acm *AsteriskConfigManager) ReloadAsterisk() error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Println("üîÑ Reloading Asterisk PJSIP module...")
	}

	// Try to find asterisk binary in common locations
	asteriskPaths := []string{
		"/usr/sbin/asterisk",
		"/usr/bin/asterisk",
		"/usr/local/sbin/asterisk",
		"/usr/local/bin/asterisk",
	}
	
	var asteriskBin string
	for _, path := range asteriskPaths {
		if _, err := os.Stat(path); err == nil {
			asteriskBin = path
			break
		}
	}
	
	// Fallback to PATH if not found in common locations
	if asteriskBin == "" {
		asteriskBin = "asterisk"
	}

	// Try to reload via asterisk CLI
	cmd := exec.Command(asteriskBin, "-rx", "module reload res_pjsip.so")
	output, err := cmd.CombinedOutput()
	
	if err != nil {
		red.Printf("‚ùå Failed to reload Asterisk: %v\n", err)
		red.Printf("Output: %s\n", string(output))
		return fmt.Errorf("failed to reload asterisk: %v", err)
	}

	if acm.verbose {
		green.Println("‚úÖ Asterisk reloaded successfully")
		if len(output) > 0 {
			fmt.Printf("   Output: %s\n", strings.TrimSpace(string(output)))
		}
	}

	return nil
}

// GenerateTransportConfig generates complete PJSIP transport configuration
func (acm *AsteriskConfigManager) GenerateTransportConfig() string {
	var config strings.Builder

	config.WriteString("; BEGIN MANAGED - RayanPBX Transports\n")
	config.WriteString("; Generated by RayanPBX - SIP Transports Configuration\n\n")
	
	// UDP Transport (primary - most common)
	config.WriteString("[transport-udp]\n")
	config.WriteString("type=transport\n")
	config.WriteString("protocol=udp\n")
	config.WriteString("bind=0.0.0.0:5060\n")
	config.WriteString("allow_reload=yes\n")
	config.WriteString("\n")
	
	// TCP Transport (for reliability and NAT traversal)
	config.WriteString("[transport-tcp]\n")
	config.WriteString("type=transport\n")
	config.WriteString("protocol=tcp\n")
	config.WriteString("bind=0.0.0.0:5060\n")
	config.WriteString("allow_reload=yes\n")
	
	config.WriteString("; END MANAGED - RayanPBX Transports\n")
	
	return config.String()
}

// EnsureTransportConfig ensures transport configuration exists in pjsip.conf
func (acm *AsteriskConfigManager) EnsureTransportConfig() error {
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Println("üì° Checking PJSIP transport configuration...")
	}

	// Read existing config
	existingContent, err := os.ReadFile(acm.pjsipConfigPath)
	if err != nil {
		if os.IsNotExist(err) {
			// Create new file with transport config
			if acm.verbose {
				yellow.Printf("‚ö†Ô∏è  Config file not found, creating: %s\n", acm.pjsipConfigPath)
			}
			header := "; RayanPBX PJSIP Configuration\n; Generated by RayanPBX\n\n"
			transportConfig := acm.GenerateTransportConfig()
			return os.WriteFile(acm.pjsipConfigPath, []byte(header+transportConfig), 0644)
		}
		return fmt.Errorf("failed to read config file: %v", err)
	}

	content := string(existingContent)
	
	// Check if transport configuration exists
	hasUDPTransport := strings.Contains(content, "[transport-udp]") && strings.Contains(content, "type=transport")
	hasTCPTransport := strings.Contains(content, "[transport-tcp]") && strings.Contains(content, "type=transport")
	
	if hasUDPTransport && hasTCPTransport {
		if acm.verbose {
			green.Println("‚úÖ PJSIP transports already configured")
		}
		return nil
	}

	if acm.verbose {
		yellow.Println("‚ö†Ô∏è  Transport configuration incomplete, updating...")
	}

	// Remove old RayanPBX transport section if exists
	pattern := `(?s); BEGIN MANAGED - RayanPBX Transports.*?; END MANAGED - RayanPBX Transports\n`
	re := regexp.MustCompile(pattern)
	content = re.ReplaceAllString(content, "")

	// Add transport config at the beginning (after any header comments)
	transportConfig := acm.GenerateTransportConfig()
	
	// Find a good place to insert - after initial comments or at the beginning
	if strings.HasPrefix(content, ";") {
		// Find end of initial comments
		lines := strings.Split(content, "\n")
		insertIdx := 0
		for i, line := range lines {
			if !strings.HasPrefix(strings.TrimSpace(line), ";") && strings.TrimSpace(line) != "" {
				insertIdx = i
				break
			}
			insertIdx = i + 1
		}
		
		// Insert transport config
		beforeInsert := strings.Join(lines[:insertIdx], "\n")
		if insertIdx > 0 {
			beforeInsert += "\n\n"
		}
		afterInsert := strings.Join(lines[insertIdx:], "\n")
		content = beforeInsert + transportConfig + "\n" + afterInsert
	} else {
		content = transportConfig + "\n" + content
	}

	// Write updated config
	err = os.WriteFile(acm.pjsipConfigPath, []byte(content), 0644)
	if err != nil {
		red.Printf("‚ùå Failed to write transport config: %v\n", err)
		return fmt.Errorf("failed to write config file: %v", err)
	}

	if acm.verbose {
		green.Println("‚úÖ Transport configuration added successfully")
	}

	return nil
}

// GenerateInternalDialplan generates dialplan configuration for internal extensions
func (acm *AsteriskConfigManager) GenerateInternalDialplan(extensions []Extension) string {
	var config strings.Builder

	config.WriteString("\n; BEGIN MANAGED - RayanPBX Internal Extensions\n")
	config.WriteString("[internal]\n")
	
	// Add individual extension rules
	for _, ext := range extensions {
		if !ext.Enabled {
			continue
		}
		
		config.WriteString(fmt.Sprintf("exten => %s,1,NoOp(Call to extension %s)\n", ext.ExtensionNumber, ext.ExtensionNumber))
		config.WriteString(fmt.Sprintf(" same => n,Dial(PJSIP/%s,30)\n", ext.ExtensionNumber))
		
		// Add voicemail if enabled
		if ext.VoicemailEnabled {
			config.WriteString(fmt.Sprintf(" same => n,VoiceMail(%s@default,u)\n", ext.ExtensionNumber))
		}
		
		config.WriteString(" same => n,Hangup()\n\n")
	}
	
	// Add pattern matching for extension-to-extension calls
	config.WriteString("; Pattern match for all extensions\n")
	config.WriteString("exten => _1XXX,1,NoOp(Extension to extension call: ${EXTEN})\n")
	config.WriteString(" same => n,Dial(PJSIP/${EXTEN},30)\n")
	config.WriteString(" same => n,Hangup()\n\n")
	
	config.WriteString("; END MANAGED - RayanPBX Internal Extensions\n")
	
	return config.String()
}

// WriteDialplanConfig writes or updates dialplan configuration in extensions.conf
func (acm *AsteriskConfigManager) WriteDialplanConfig(content, identifier string) error {
	extensionsConfigPath := "/etc/asterisk/extensions.conf"
	
	cyan := color.New(color.FgCyan)
	green := color.New(color.FgGreen)
	yellow := color.New(color.FgYellow)
	red := color.New(color.FgRed)

	if acm.verbose {
		cyan.Printf("üìù Updating dialplan file: %s\n", extensionsConfigPath)
		cyan.Printf("   Identifier: %s\n", identifier)
	}

	// Check if file exists
	existingContent, err := os.ReadFile(extensionsConfigPath)
	if err != nil {
		// If file doesn't exist, try to create it with proper header
		if os.IsNotExist(err) {
			yellow.Printf("‚ö†Ô∏è  Dialplan file not found, creating: %s\n", extensionsConfigPath)
			header := "; RayanPBX Dialplan Configuration\n; Generated by RayanPBX TUI\n\n"
			existingContent = []byte(header)
		} else {
			return fmt.Errorf("failed to read dialplan file: %v", err)
		}
	}

	// Remove old managed section for this identifier
	pattern := fmt.Sprintf(`(?s); BEGIN MANAGED - %s.*?; END MANAGED - %s\n`, regexp.QuoteMeta(identifier), regexp.QuoteMeta(identifier))
	re := regexp.MustCompile(pattern)
	newContent := re.ReplaceAllString(string(existingContent), "")

	// Append new config
	newContent += content

	// Write to file
	err = os.WriteFile(extensionsConfigPath, []byte(newContent), 0644)
	if err != nil {
		red.Printf("‚ùå Failed to write dialplan file: %v\n", err)
		yellow.Println("üí° Tip: Make sure the TUI has write permissions to /etc/asterisk/")
		yellow.Println("üí° Try running with: sudo rayanpbx-tui")
		return fmt.Errorf("failed to write dialplan file: %v", err)
	}

	if acm.verbose {
		green.Printf("‚úÖ Dialplan updated successfully\n")
		green.Printf("   File: %s\n", extensionsConfigPath)
	}

	return nil
}
