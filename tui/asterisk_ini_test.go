package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestNewAsteriskSection(t *testing.T) {
	section := NewAsteriskSection("101", "endpoint")

	if section.Name != "101" {
		t.Errorf("Expected section name '101', got '%s'", section.Name)
	}
	if section.Type != "endpoint" {
		t.Errorf("Expected section type 'endpoint', got '%s'", section.Type)
	}
	if section.Properties == nil {
		t.Error("Expected Properties map to be initialized")
	}
	if section.Keys == nil {
		t.Error("Expected Keys slice to be initialized")
	}
}

func TestSectionSetProperty(t *testing.T) {
	section := NewAsteriskSection("test", "endpoint")
	
	section.SetProperty("key1", "value1")
	section.SetProperty("key2", "value2")
	section.SetProperty("key1", "updated") // Update existing

	if len(section.Keys) != 2 {
		t.Errorf("Expected 2 keys, got %d", len(section.Keys))
	}

	val, ok := section.GetProperty("key1")
	if !ok || val != "updated" {
		t.Errorf("Expected 'updated', got '%s'", val)
	}

	val, ok = section.GetProperty("key2")
	if !ok || val != "value2" {
		t.Errorf("Expected 'value2', got '%s'", val)
	}
}

func TestSectionString(t *testing.T) {
	section := NewAsteriskSection("101", "endpoint")
	section.SetProperty("type", "endpoint")
	section.SetProperty("context", "from-internal")
	section.SetProperty("disallow", "all")

	output := section.String()

	if !strings.Contains(output, "[101]") {
		t.Error("Expected output to contain section header")
	}
	if !strings.Contains(output, "type=endpoint") {
		t.Error("Expected output to contain type=endpoint")
	}
	if !strings.Contains(output, "context=from-internal") {
		t.Error("Expected output to contain context")
	}
}

func TestParseAsteriskConfigContent(t *testing.T) {
	content := `; RayanPBX PJSIP Configuration
; Generated by RayanPBX

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060

[101]
type=endpoint
context=from-internal
auth=101
aors=101

[101]
type=auth
auth_type=userpass
username=101
password=secret

[101]
type=aor
max_contacts=1
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Check header lines (includes the two comment lines and empty line)
	if len(config.HeaderLines) < 2 {
		t.Errorf("Expected at least 2 header lines, got %d", len(config.HeaderLines))
	}

	// Check sections
	if len(config.Sections) != 4 {
		t.Errorf("Expected 4 sections, got %d", len(config.Sections))
	}

	// Check transport section
	transport := config.FindSectionByNameAndType("transport-udp", "transport")
	if transport == nil {
		t.Error("Expected to find transport-udp section")
	} else {
		proto, _ := transport.GetProperty("protocol")
		if proto != "udp" {
			t.Errorf("Expected protocol 'udp', got '%s'", proto)
		}
	}

	// Check multiple sections with same name
	ext101Sections := config.FindSectionsByName("101")
	if len(ext101Sections) != 3 {
		t.Errorf("Expected 3 sections named '101', got %d", len(ext101Sections))
	}

	// Check specific section by name and type
	endpoint := config.FindSectionByNameAndType("101", "endpoint")
	if endpoint == nil {
		t.Error("Expected to find 101 endpoint section")
	} else {
		ctx, _ := endpoint.GetProperty("context")
		if ctx != "from-internal" {
			t.Errorf("Expected context 'from-internal', got '%s'", ctx)
		}
	}

	auth := config.FindSectionByNameAndType("101", "auth")
	if auth == nil {
		t.Error("Expected to find 101 auth section")
	} else {
		pass, _ := auth.GetProperty("password")
		if pass != "secret" {
			t.Errorf("Expected password 'secret', got '%s'", pass)
		}
	}
}

func TestConfigRemoveSections(t *testing.T) {
	content := `[transport-udp]
type=transport
protocol=udp

[101]
type=endpoint

[101]
type=auth

[102]
type=endpoint
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Remove all 101 sections
	removed := config.RemoveSectionsByName("101")
	if removed != 2 {
		t.Errorf("Expected to remove 2 sections, removed %d", removed)
	}

	if config.HasSection("101") {
		t.Error("Section 101 should have been removed")
	}

	// Transport and 102 should still exist
	if !config.HasSection("transport-udp") {
		t.Error("transport-udp should still exist")
	}
	if !config.HasSection("102") {
		t.Error("102 should still exist")
	}
}

func TestConfigRemoveSectionByType(t *testing.T) {
	content := `[101]
type=endpoint

[101]
type=auth

[101]
type=aor
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Remove only the auth section
	removed := config.RemoveSectionByNameAndType("101", "auth")
	if !removed {
		t.Error("Expected to remove auth section")
	}

	// Should have 2 sections left
	if len(config.Sections) != 2 {
		t.Errorf("Expected 2 sections, got %d", len(config.Sections))
	}

	// endpoint and aor should remain
	if !config.HasSectionWithType("101", "endpoint") {
		t.Error("endpoint section should still exist")
	}
	if !config.HasSectionWithType("101", "aor") {
		t.Error("aor section should still exist")
	}
	if config.HasSectionWithType("101", "auth") {
		t.Error("auth section should have been removed")
	}
}

func TestConfigAddOrReplaceSection(t *testing.T) {
	content := `[101]
type=endpoint
context=old-context
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Create replacement section
	newSection := NewAsteriskSection("101", "endpoint")
	newSection.SetProperty("type", "endpoint")
	newSection.SetProperty("context", "new-context")

	config.AddOrReplaceSection(newSection)

	// Should still have 1 section
	if len(config.Sections) != 1 {
		t.Errorf("Expected 1 section, got %d", len(config.Sections))
	}

	// Context should be updated
	section := config.FindSectionByNameAndType("101", "endpoint")
	ctx, _ := section.GetProperty("context")
	if ctx != "new-context" {
		t.Errorf("Expected context 'new-context', got '%s'", ctx)
	}
}

func TestConfigRoundTrip(t *testing.T) {
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "pjsip.conf")

	// Create initial content
	initial := `; Test config
[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060

[101]
type=endpoint
context=from-internal
`

	err := os.WriteFile(testFile, []byte(initial), 0644)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Parse
	config, err := ParseAsteriskConfig(testFile)
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Add new section
	auth := NewAsteriskSection("101", "auth")
	auth.SetProperty("type", "auth")
	auth.SetProperty("password", "secret123")
	config.AddSection(auth)

	// Save
	err = config.Save()
	if err != nil {
		t.Fatalf("Failed to save config: %v", err)
	}

	// Re-read and verify
	config2, err := ParseAsteriskConfig(testFile)
	if err != nil {
		t.Fatalf("Failed to re-parse config: %v", err)
	}

	if len(config2.Sections) != 3 {
		t.Errorf("Expected 3 sections after save, got %d", len(config2.Sections))
	}

	authSection := config2.FindSectionByNameAndType("101", "auth")
	if authSection == nil {
		t.Error("Expected to find 101 auth section after save")
	} else {
		pass, _ := authSection.GetProperty("password")
		if pass != "secret123" {
			t.Errorf("Expected password 'secret123', got '%s'", pass)
		}
	}
}

func TestCreatePjsipEndpointSections(t *testing.T) {
	codecs := []string{"ulaw", "alaw", "g722"}
	sections := CreatePjsipEndpointSections(
		"101",
		"secretpass",
		"from-internal",
		"transport-udp",
		codecs,
		"no",
		"John Doe <101>",
		2,
		60,
		true,
	)

	if len(sections) != 3 {
		t.Errorf("Expected 3 sections, got %d", len(sections))
	}

	// Check endpoint
	endpoint := sections[0]
	if endpoint.Type != "endpoint" {
		t.Errorf("Expected first section type 'endpoint', got '%s'", endpoint.Type)
	}
	ctx, _ := endpoint.GetProperty("context")
	if ctx != "from-internal" {
		t.Errorf("Expected context 'from-internal', got '%s'", ctx)
	}

	// Check auth
	auth := sections[1]
	if auth.Type != "auth" {
		t.Errorf("Expected second section type 'auth', got '%s'", auth.Type)
	}
	pass, _ := auth.GetProperty("password")
	if pass != "secretpass" {
		t.Errorf("Expected password 'secretpass', got '%s'", pass)
	}

	// Check aor
	aor := sections[2]
	if aor.Type != "aor" {
		t.Errorf("Expected third section type 'aor', got '%s'", aor.Type)
	}
	maxContacts, _ := aor.GetProperty("max_contacts")
	if maxContacts != "2" {
		t.Errorf("Expected max_contacts '2', got '%s'", maxContacts)
	}
}

func TestCreateTransportSections(t *testing.T) {
	sections := CreateTransportSections()

	if len(sections) != 2 {
		t.Errorf("Expected 2 transport sections, got %d", len(sections))
	}

	udp := sections[0]
	if udp.Name != "transport-udp" {
		t.Errorf("Expected first section name 'transport-udp', got '%s'", udp.Name)
	}
	proto, _ := udp.GetProperty("protocol")
	if proto != "udp" {
		t.Errorf("Expected protocol 'udp', got '%s'", proto)
	}

	tcp := sections[1]
	if tcp.Name != "transport-tcp" {
		t.Errorf("Expected second section name 'transport-tcp', got '%s'", tcp.Name)
	}
	proto, _ = tcp.GetProperty("protocol")
	if proto != "tcp" {
		t.Errorf("Expected protocol 'tcp', got '%s'", proto)
	}
}

func TestParseExistingConfig(t *testing.T) {
	// Test that we can correctly parse a config using section-based identification
	content := `; Existing asterisk config

[global]
type=global
max_forwards=70

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0

[100]
type=endpoint
context=default

[100]
type=auth
auth_type=userpass
username=100
password=test

[100]
type=aor
max_contacts=5
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Should have 5 sections
	if len(config.Sections) != 5 {
		t.Errorf("Expected 5 sections, got %d", len(config.Sections))
	}

	// Verify we can identify and modify existing sections
	ext100 := config.FindSectionByNameAndType("100", "endpoint")
	if ext100 == nil {
		t.Error("Expected to find 100 endpoint")
	} else {
		// Update context
		ext100.SetProperty("context", "from-internal")
		ctx, _ := ext100.GetProperty("context")
		if ctx != "from-internal" {
			t.Errorf("Expected updated context 'from-internal', got '%s'", ctx)
		}
	}

	// Verify we can add a new extension without markers
	newSections := CreatePjsipEndpointSections(
		"101",
		"pass101",
		"from-internal",
		"transport-udp",
		[]string{"ulaw"},
		"no",
		"",
		1,
		60,
		false,
	)

	for _, s := range newSections {
		config.AddSection(s)
	}

	// Should now have 8 sections
	if len(config.Sections) != 8 {
		t.Errorf("Expected 8 sections after adding extension, got %d", len(config.Sections))
	}

	// Verify we can remove the new extension by name
	removed := config.RemoveSectionsByName("101")
	if removed != 3 {
		t.Errorf("Expected to remove 3 sections, removed %d", removed)
	}

	// Should be back to 5 sections
	if len(config.Sections) != 5 {
		t.Errorf("Expected 5 sections after removal, got %d", len(config.Sections))
	}
}

func TestPreserveKeyOrder(t *testing.T) {
	section := NewAsteriskSection("test", "endpoint")
	
	// Add properties in specific order
	section.SetProperty("type", "endpoint")
	section.SetProperty("context", "from-internal")
	section.SetProperty("disallow", "all")
	section.SetProperty("allow", "ulaw")
	section.SetProperty("transport", "transport-udp")

	output := section.String()
	lines := strings.Split(output, "\n")

	// Verify order is preserved
	expectedOrder := []string{"type=", "context=", "disallow=", "allow=", "transport="}
	lineIdx := 1 // Skip section header

	for i, prefix := range expectedOrder {
		if lineIdx >= len(lines) {
			t.Errorf("Not enough lines in output at index %d", i)
			break
		}
		if !strings.HasPrefix(lines[lineIdx], prefix) {
			t.Errorf("Expected line %d to start with '%s', got '%s'", lineIdx, prefix, lines[lineIdx])
		}
		lineIdx++
	}
}
