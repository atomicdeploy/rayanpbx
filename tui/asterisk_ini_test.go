package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestNewAsteriskSection(t *testing.T) {
	section := NewAsteriskSection("101", "endpoint")

	if section.Name != "101" {
		t.Errorf("Expected section name '101', got '%s'", section.Name)
	}
	if section.Type != "endpoint" {
		t.Errorf("Expected section type 'endpoint', got '%s'", section.Type)
	}
	if section.Properties == nil {
		t.Error("Expected Properties map to be initialized")
	}
	if section.Keys == nil {
		t.Error("Expected Keys slice to be initialized")
	}
}

func TestSectionSetProperty(t *testing.T) {
	section := NewAsteriskSection("test", "endpoint")
	
	section.SetProperty("key1", "value1")
	section.SetProperty("key2", "value2")
	section.SetProperty("key1", "updated") // Update existing

	if len(section.Keys) != 2 {
		t.Errorf("Expected 2 keys, got %d", len(section.Keys))
	}

	val, ok := section.GetProperty("key1")
	if !ok || val != "updated" {
		t.Errorf("Expected 'updated', got '%s'", val)
	}

	val, ok = section.GetProperty("key2")
	if !ok || val != "value2" {
		t.Errorf("Expected 'value2', got '%s'", val)
	}
}

func TestSectionString(t *testing.T) {
	section := NewAsteriskSection("101", "endpoint")
	section.SetProperty("type", "endpoint")
	section.SetProperty("context", "from-internal")
	section.SetProperty("disallow", "all")

	output := section.String()

	if !strings.Contains(output, "[101]") {
		t.Error("Expected output to contain section header")
	}
	if !strings.Contains(output, "type=endpoint") {
		t.Error("Expected output to contain type=endpoint")
	}
	if !strings.Contains(output, "context=from-internal") {
		t.Error("Expected output to contain context")
	}
}

func TestParseAsteriskConfigContent(t *testing.T) {
	content := `; RayanPBX PJSIP Configuration
; Generated by RayanPBX

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060

[101]
type=endpoint
context=from-internal
auth=101
aors=101

[101]
type=auth
auth_type=userpass
username=101
password=secret

[101]
type=aor
max_contacts=1
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Check header lines (includes the two comment lines and empty line)
	if len(config.HeaderLines) < 2 {
		t.Errorf("Expected at least 2 header lines, got %d", len(config.HeaderLines))
	}

	// Check sections
	if len(config.Sections) != 4 {
		t.Errorf("Expected 4 sections, got %d", len(config.Sections))
	}

	// Check transport section
	transport := config.FindSectionByNameAndType("transport-udp", "transport")
	if transport == nil {
		t.Error("Expected to find transport-udp section")
	} else {
		proto, _ := transport.GetProperty("protocol")
		if proto != "udp" {
			t.Errorf("Expected protocol 'udp', got '%s'", proto)
		}
	}

	// Check multiple sections with same name
	ext101Sections := config.FindSectionsByName("101")
	if len(ext101Sections) != 3 {
		t.Errorf("Expected 3 sections named '101', got %d", len(ext101Sections))
	}

	// Check specific section by name and type
	endpoint := config.FindSectionByNameAndType("101", "endpoint")
	if endpoint == nil {
		t.Error("Expected to find 101 endpoint section")
	} else {
		ctx, _ := endpoint.GetProperty("context")
		if ctx != "from-internal" {
			t.Errorf("Expected context 'from-internal', got '%s'", ctx)
		}
	}

	auth := config.FindSectionByNameAndType("101", "auth")
	if auth == nil {
		t.Error("Expected to find 101 auth section")
	} else {
		pass, _ := auth.GetProperty("password")
		if pass != "secret" {
			t.Errorf("Expected password 'secret', got '%s'", pass)
		}
	}
}

func TestConfigRemoveSections(t *testing.T) {
	content := `[transport-udp]
type=transport
protocol=udp

[101]
type=endpoint

[101]
type=auth

[102]
type=endpoint
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Remove all 101 sections
	removed := config.RemoveSectionsByName("101")
	if removed != 2 {
		t.Errorf("Expected to remove 2 sections, removed %d", removed)
	}

	if config.HasSection("101") {
		t.Error("Section 101 should have been removed")
	}

	// Transport and 102 should still exist
	if !config.HasSection("transport-udp") {
		t.Error("transport-udp should still exist")
	}
	if !config.HasSection("102") {
		t.Error("102 should still exist")
	}
}

func TestConfigRemoveSectionByType(t *testing.T) {
	content := `[101]
type=endpoint

[101]
type=auth

[101]
type=aor
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Remove only the auth section
	removed := config.RemoveSectionByNameAndType("101", "auth")
	if !removed {
		t.Error("Expected to remove auth section")
	}

	// Should have 2 sections left
	if len(config.Sections) != 2 {
		t.Errorf("Expected 2 sections, got %d", len(config.Sections))
	}

	// endpoint and aor should remain
	if !config.HasSectionWithType("101", "endpoint") {
		t.Error("endpoint section should still exist")
	}
	if !config.HasSectionWithType("101", "aor") {
		t.Error("aor section should still exist")
	}
	if config.HasSectionWithType("101", "auth") {
		t.Error("auth section should have been removed")
	}
}

func TestConfigAddOrReplaceSection(t *testing.T) {
	content := `[101]
type=endpoint
context=old-context
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Create replacement section
	newSection := NewAsteriskSection("101", "endpoint")
	newSection.SetProperty("type", "endpoint")
	newSection.SetProperty("context", "new-context")

	config.AddOrReplaceSection(newSection)

	// Should still have 1 section
	if len(config.Sections) != 1 {
		t.Errorf("Expected 1 section, got %d", len(config.Sections))
	}

	// Context should be updated
	section := config.FindSectionByNameAndType("101", "endpoint")
	ctx, _ := section.GetProperty("context")
	if ctx != "new-context" {
		t.Errorf("Expected context 'new-context', got '%s'", ctx)
	}
}

func TestConfigRoundTrip(t *testing.T) {
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "pjsip.conf")

	// Create initial content
	initial := `; Test config
[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060

[101]
type=endpoint
context=from-internal
`

	err := os.WriteFile(testFile, []byte(initial), 0644)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Parse
	config, err := ParseAsteriskConfig(testFile)
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Add new section
	auth := NewAsteriskSection("101", "auth")
	auth.SetProperty("type", "auth")
	auth.SetProperty("password", "secret123")
	config.AddSection(auth)

	// Save
	err = config.Save()
	if err != nil {
		t.Fatalf("Failed to save config: %v", err)
	}

	// Re-read and verify
	config2, err := ParseAsteriskConfig(testFile)
	if err != nil {
		t.Fatalf("Failed to re-parse config: %v", err)
	}

	if len(config2.Sections) != 3 {
		t.Errorf("Expected 3 sections after save, got %d", len(config2.Sections))
	}

	authSection := config2.FindSectionByNameAndType("101", "auth")
	if authSection == nil {
		t.Error("Expected to find 101 auth section after save")
	} else {
		pass, _ := authSection.GetProperty("password")
		if pass != "secret123" {
			t.Errorf("Expected password 'secret123', got '%s'", pass)
		}
	}
}

func TestCreatePjsipEndpointSections(t *testing.T) {
	codecs := []string{"ulaw", "alaw", "g722"}
	sections := CreatePjsipEndpointSections(
		"101",
		"secretpass",
		"from-internal",
		"transport-udp",
		codecs,
		"no",
		"John Doe <101>",
		2,
		60,
		true,
	)

	if len(sections) != 3 {
		t.Errorf("Expected 3 sections, got %d", len(sections))
	}

	// Check endpoint
	endpoint := sections[0]
	if endpoint.Type != "endpoint" {
		t.Errorf("Expected first section type 'endpoint', got '%s'", endpoint.Type)
	}
	ctx, _ := endpoint.GetProperty("context")
	if ctx != "from-internal" {
		t.Errorf("Expected context 'from-internal', got '%s'", ctx)
	}

	// Check auth
	auth := sections[1]
	if auth.Type != "auth" {
		t.Errorf("Expected second section type 'auth', got '%s'", auth.Type)
	}
	pass, _ := auth.GetProperty("password")
	if pass != "secretpass" {
		t.Errorf("Expected password 'secretpass', got '%s'", pass)
	}

	// Check aor
	aor := sections[2]
	if aor.Type != "aor" {
		t.Errorf("Expected third section type 'aor', got '%s'", aor.Type)
	}
	maxContacts, _ := aor.GetProperty("max_contacts")
	if maxContacts != "2" {
		t.Errorf("Expected max_contacts '2', got '%s'", maxContacts)
	}
}

func TestCreateTransportSections(t *testing.T) {
	sections := CreateTransportSections()

	if len(sections) != 2 {
		t.Errorf("Expected 2 transport sections, got %d", len(sections))
	}

	udp := sections[0]
	if udp.Name != "transport-udp" {
		t.Errorf("Expected first section name 'transport-udp', got '%s'", udp.Name)
	}
	proto, _ := udp.GetProperty("protocol")
	if proto != "udp" {
		t.Errorf("Expected protocol 'udp', got '%s'", proto)
	}

	tcp := sections[1]
	if tcp.Name != "transport-tcp" {
		t.Errorf("Expected second section name 'transport-tcp', got '%s'", tcp.Name)
	}
	proto, _ = tcp.GetProperty("protocol")
	if proto != "tcp" {
		t.Errorf("Expected protocol 'tcp', got '%s'", proto)
	}
}

func TestParseExistingConfig(t *testing.T) {
	// Test that we can correctly parse a config using section-based identification
	content := `; Existing asterisk config

[global]
type=global
max_forwards=70

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0

[100]
type=endpoint
context=default

[100]
type=auth
auth_type=userpass
username=100
password=test

[100]
type=aor
max_contacts=5
`

	config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
	if err != nil {
		t.Fatalf("Failed to parse config: %v", err)
	}

	// Should have 5 sections
	if len(config.Sections) != 5 {
		t.Errorf("Expected 5 sections, got %d", len(config.Sections))
	}

	// Verify we can identify and modify existing sections
	ext100 := config.FindSectionByNameAndType("100", "endpoint")
	if ext100 == nil {
		t.Error("Expected to find 100 endpoint")
	} else {
		// Update context
		ext100.SetProperty("context", "from-internal")
		ctx, _ := ext100.GetProperty("context")
		if ctx != "from-internal" {
			t.Errorf("Expected updated context 'from-internal', got '%s'", ctx)
		}
	}

	// Verify we can add a new extension without markers
	newSections := CreatePjsipEndpointSections(
		"101",
		"pass101",
		"from-internal",
		"transport-udp",
		[]string{"ulaw"},
		"no",
		"",
		1,
		60,
		false,
	)

	for _, s := range newSections {
		config.AddSection(s)
	}

	// Should now have 8 sections
	if len(config.Sections) != 8 {
		t.Errorf("Expected 8 sections after adding extension, got %d", len(config.Sections))
	}

	// Verify we can remove the new extension by name
	removed := config.RemoveSectionsByName("101")
	if removed != 3 {
		t.Errorf("Expected to remove 3 sections, removed %d", removed)
	}

	// Should be back to 5 sections
	if len(config.Sections) != 5 {
		t.Errorf("Expected 5 sections after removal, got %d", len(config.Sections))
	}
}

func TestPreserveKeyOrder(t *testing.T) {
	section := NewAsteriskSection("test", "endpoint")
	
	// Add properties in specific order
	section.SetProperty("type", "endpoint")
	section.SetProperty("context", "from-internal")
	section.SetProperty("disallow", "all")
	section.SetProperty("allow", "ulaw")
	section.SetProperty("transport", "transport-udp")

	output := section.String()
	lines := strings.Split(output, "\n")

	// Verify order is preserved
	expectedOrder := []string{"type=", "context=", "disallow=", "allow=", "transport="}
	lineIdx := 1 // Skip section header

	for i, prefix := range expectedOrder {
		if lineIdx >= len(lines) {
			t.Errorf("Not enough lines in output at index %d", i)
			break
		}
		if !strings.HasPrefix(lines[lineIdx], prefix) {
			t.Errorf("Expected line %d to start with '%s', got '%s'", lineIdx, prefix, lines[lineIdx])
		}
		lineIdx++
	}
}


func TestCommentedSectionParsing(t *testing.T) {
content := `; Regular comment
[transport-udp]
type=transport
protocol=udp

;[101]
;type=endpoint
;context=from-internal

[102]
type=endpoint
context=from-internal
`

config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
if err != nil {
t.Fatalf("Failed to parse config: %v", err)
}

// Should have 3 sections: transport-udp (active), 101 (commented), 102 (active)
if len(config.Sections) != 3 {
t.Errorf("Expected 3 sections, got %d", len(config.Sections))
}

// Check that 101 is marked as commented
ext101 := config.FindSectionsByName("101")
if len(ext101) != 1 {
t.Fatalf("Expected 1 section named '101', got %d", len(ext101))
}
if !ext101[0].Commented {
t.Error("Expected section 101 to be marked as Commented")
}
if ext101[0].Type != "endpoint" {
t.Errorf("Expected type 'endpoint' for commented section, got '%s'", ext101[0].Type)
}

// Check that 102 is NOT commented
ext102 := config.FindSectionsByName("102")
if len(ext102) != 1 {
t.Fatalf("Expected 1 section named '102', got %d", len(ext102))
}
if ext102[0].Commented {
t.Error("Section 102 should NOT be marked as Commented")
}
}

func TestCommentOutSections(t *testing.T) {
content := `[101]
type=endpoint
context=from-internal

[101]
type=auth
password=secret
`

config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
if err != nil {
t.Fatalf("Failed to parse config: %v", err)
}

// Comment out all 101 sections
commented := config.CommentOutSectionsByName("101")
if commented != 2 {
t.Errorf("Expected to comment out 2 sections, got %d", commented)
}

// Verify they are now commented
for _, section := range config.FindSectionsByName("101") {
if !section.Commented {
t.Error("Section should be marked as Commented after CommentOutSectionsByName")
}
}

// Render and verify output
output := config.String()
if !strings.Contains(output, ";[101]") {
t.Error("Expected output to contain commented section header ';[101]'")
}
if !strings.Contains(output, ";type=endpoint") {
t.Error("Expected output to contain commented properties")
}
}

func TestUncommentSections(t *testing.T) {
content := `;[101]
;type=endpoint
;context=from-internal

;[101]
;type=auth
;password=secret
`

config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
if err != nil {
t.Fatalf("Failed to parse config: %v", err)
}

// Verify they start as commented
for _, section := range config.FindSectionsByName("101") {
if !section.Commented {
t.Fatal("Sections should start as Commented")
}
}

// Uncomment all 101 sections
uncommented := config.UncommentSectionsByName("101")
if uncommented != 2 {
t.Errorf("Expected to uncomment 2 sections, got %d", uncommented)
}

// Verify they are now active
for _, section := range config.FindSectionsByName("101") {
if section.Commented {
t.Error("Section should NOT be marked as Commented after UncommentSectionsByName")
}
}

// Render and verify output
output := config.String()
if strings.Contains(output, ";[101]") {
t.Error("Output should NOT contain commented section header ';[101]' after uncommenting")
}
if !strings.Contains(output, "[101]") {
t.Error("Output should contain active section header '[101]'")
}
}

func TestFindActiveSections(t *testing.T) {
content := `[101]
type=endpoint

;[101]
;type=auth
`

config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
if err != nil {
t.Fatalf("Failed to parse config: %v", err)
}

active := config.FindActiveSectionsByName("101")
if len(active) != 1 {
t.Errorf("Expected 1 active section, got %d", len(active))
}
if active[0].Type != "endpoint" {
t.Errorf("Expected active section type 'endpoint', got '%s'", active[0].Type)
}

commented := config.FindCommentedSectionsByName("101")
if len(commented) != 1 {
t.Errorf("Expected 1 commented section, got %d", len(commented))
}
if commented[0].Type != "auth" {
t.Errorf("Expected commented section type 'auth', got '%s'", commented[0].Type)
}
}

func TestRemoveCommentedSectionsOnly(t *testing.T) {
content := `[101]
type=endpoint

;[101]
;type=auth

[102]
type=endpoint
`

config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
if err != nil {
t.Fatalf("Failed to parse config: %v", err)
}

// Remove only commented sections for 101
removed := config.RemoveCommentedSectionsByName("101")
if removed != 1 {
t.Errorf("Expected to remove 1 commented section, got %d", removed)
}

// Active 101 section should still exist
active := config.FindActiveSectionsByName("101")
if len(active) != 1 {
t.Errorf("Active section for 101 should still exist, got %d", len(active))
}

// Total sections should be 2 (101 endpoint, 102 endpoint)
if len(config.Sections) != 2 {
t.Errorf("Expected 2 sections total, got %d", len(config.Sections))
}
}

func TestHasActiveAndCommentedSection(t *testing.T) {
content := `[101]
type=endpoint

;[102]
;type=endpoint
`

config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
if err != nil {
t.Fatalf("Failed to parse config: %v", err)
}

// 101 should have active section
if !config.HasActiveSection("101") {
t.Error("HasActiveSection should return true for 101")
}
if config.HasCommentedSection("101") {
t.Error("HasCommentedSection should return false for 101")
}

// 102 should have commented section only
if config.HasActiveSection("102") {
t.Error("HasActiveSection should return false for 102")
}
if !config.HasCommentedSection("102") {
t.Error("HasCommentedSection should return true for 102")
}

// 103 should have neither
if config.HasActiveSection("103") {
t.Error("HasActiveSection should return false for 103")
}
if config.HasCommentedSection("103") {
t.Error("HasCommentedSection should return false for 103")
}
}

func TestBodyCommentsPreserved(t *testing.T) {
content := `[101]
type=endpoint
; This is a body comment within the section
context=from-internal
`

config, err := ParseAsteriskConfigContent(content, "/tmp/test.conf")
if err != nil {
t.Fatalf("Failed to parse config: %v", err)
}

section := config.FindSectionsByName("101")[0]
if len(section.BodyComments) != 1 {
t.Errorf("Expected 1 body comment, got %d", len(section.BodyComments))
}
}
